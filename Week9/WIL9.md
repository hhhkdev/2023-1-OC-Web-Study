# 9주차

[[기초 웹 스터디 9주차 과제]](https://www.gdschongik.com/web-study/subject/9)

## **마감 기한**

****2023년 05월 30일 00시 까지****

자바스크립트: 4, 10, 12, 27, 30, 32.3, 32.4번

[PoiemaWeb](https://poiemaweb.com/)

[🌐 브라우저 이벤트 종류 & 사용법 총정리](https://inpa.tistory.com/entry/JS-📚-이벤트-💯-총-정리)

# 5.4 브라우저 동작 원리

**브라우저의 핵심 기능**: 사용자가 참조하고자 하는 웹페이지를 서버에 `요청(Request)`하고 서버의 `응답(Response)`을 받아 브라우저에 표시하는 것.

브라우저는 서버로부터 `HTML`, `CSS`, `JavaScript`, `이미지 파일` 등을 응답받음.

HTML과 CSS 파일은 렌더링 엔진의 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고, 렌더 트리로 결합됨. → 이렇게 생성된 렌더 트리를 기반으로 웹페이지를 표시함.

자바스크립트는 자바스크립트 엔진이 처리함. 

→ HTML 파서는 `<script>` 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘김. 

→ 자바스크립트 엔진은 `<script>` 태그 내 자바스크립트 코드, `src` 어트리뷰트에 정의된 자바스크립트 파일 등을 로드하고 파싱하여 실행함. 

→ 이후 다시 HTML 파서로 제어 권한을 넘겨 DOM 생성을 재개함.

**동기(Synchronous)**적 처리 → `<script>` 태그 위치에 따라 DOM 생성이 지연될 수도.

`**body` 요소의 가장 아래에 자바스크립트를 위치시키는 것**

- HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축됨.
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생함.

# 5.10 객체

자바스크립트의 객체: 키(Key)와 값(Value)으로 구성된 프로퍼티(Property)의 집합.

## 객체 리터럴

```jsx
var person = {
	name: 'Lee',
	gender: 'male',
	sayHello: function() {
		console.log("Hi! I'm " + this.name);
	}
};
```

가장 일반적인 객체 생성 방식

## Object 생성자 함수

new 연산자와 Object 생성자 함수를 호출하여 빈 객체를 생성할 수 있음. 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성하는 방법.

객체 리터럴 방식은 Object 생성자 함수로 객체를 생성하는 것을 단순화시킨 축약 표현.

## 생성자 함수

객체를 생성하기 위한 템플릿(클래스)처럼 사용하여 프로퍼티가 동일한 객체 여러 개를 간편하게 생성하게 함.

```jsx
function Person(name, gender) {
	this.name = name;
	this.gender = gender;
	this.sayHello = function(){
		console.log("Hi! I'm " + this.name);
	};
}
```

- 생성자 함수는 일반적으로 대문자로 시작함. 생성자 함수임을 인식할 수 있도록.
- this는 생성자 함수가 생성할 인스턴스를 가리킴.
- this에 연견되어 있는 프로퍼티와 메소드는 public.
- 생성자 함수 내에서 선언된 일반 변수는 private.

# Pass-by-reference

원시 타입은 immutable하지만, 객체는 프로퍼티의 변경, 추가, 삭제가 가능하므로 mutable.

원시타입은 값으로 복사되어 전달됨. **pass-by-value.**

# 5.12 함수

자바스크립트에서 함수는 **일급 객체**

- 무명의 리터럴로 표현이 가능함.
- 변수나 자료구조에 저장할 수 있음.
- 함수의 파라미터로 전달할 수 있음.
- 반환값(return value)로 사용할 수 있음.

함수와 다른 객체를 구분짓는 특징은 호출할 수 있다는 것.

함수도 객체이므로 프로퍼티를 가질 수 있음.

### arguments 프로퍼티

함수 호출 시 전달된 인수(argument)들의 정보를 담고 있은 iterable한 유사 배열 객체.

### caller 프로퍼티

자신을 호출한 함수를 의미함.

### length 프로퍼티

함수 정의 시 작성된 매개변수 개수를 의미함.

arguments.length는 함수 호출 시 인자의 개수.

### name 프로퍼티

함수명. 기명 함수의 경우 함수명을 값을 익명 함수는 빈 문자열을 값으로 가짐.

### prototype 프로퍼티

prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티.

함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체를 가리킴.

# 5.28 배열

배열은 Array 생성자로 생성된 Array 타입의 객체이며 프로토타입 객체는 Array.prototype.

### Array.length

요소의 개수, 배열의 길이.

배열 요소의 개수와 length 프로퍼티 값이 반드시 일치하지는 않음. 희소배열.

# 5.30 DOM

브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재함.

모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것.

- **HTML 문서에 대한 모델 구성**: 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성. 이때 모델은 객체의 트리로 구성되는데 이를 DOM 트리라 함.
- **HTML 문서 내의 각 요소에 접근/수정**: DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공함. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경됨.

## DOM tree

브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델.

- **문서 노드(Document Node)**: 트리의 최상위에 존재하며 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 함. 시작점(Entry point)
- **요소 노드(Element Node)**: 요소 노드는 HTML 요소를 표현함. HTML 요소는 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화함. 따라서 요소 노드는 문서의 구조를 서술한다고 말 할 수 있음. 어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 함. 모든 요소 노드는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성됨.
- **어트리뷰트 노드(Attribute Node)**: 어트리뷰트 노드는 HTML 요소의 어트리뷰트를 표현함. 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현됨. 따라서 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있음.
- **텍스트 노드(Text Node)**: 텍스트 노드는 HTML 요소의 텍스트를 표현함. 텍스트 노드는 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없음. 즉, 텍스트 노드는 DOM tree의 최종단.

# 5.32 이벤트

## 이벤트 핸들러 등록

### 1. 인라인 이벤트 핸들러 방식

HTML 요소의 이벤트 핸들러 어트리뷰트에 이벤트 핸들러를 등록하는 방법. 더이상 사용되지 않음.

### 2. 이벤트 핸들러 프로퍼티 방식

HTML과 Javascript가 뒤섞이는 문제를 해결하는 방식. 이벤트 핸들러 프로퍼티에 하나의 이벤드 핸들러만 바인딩한다는 단점.

### 3. addEventListener 메소드 방식

대상 DOM 요소에 이벤트를 바인딩하고 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정함.

```jsx
EventTarget.addEventListener('eventType', functionName [, useCapture]);
```

- 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가함.
- 캡쳐링과 버블링을 지원함
- HTML 요소뿐만아니라 모든 DOM 요소에 대해 동작함. 브라우저는 웹 문서를 로드한 후, 파싱하여 DOM을 생성함.